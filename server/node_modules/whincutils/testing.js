
var extend		= require('util')._extend;
var bunyan		= require('bunyan')
var Promise		= require('promise')
var requests		= require('request')

var log			= bunyan.createLogger({
    name: "Testing",
    level: 'error'
});
var Testing		= {};

function createAssertionNamespace(namespace) {
    function assert(condition, message) {
	assert.count++;
	if (condition !== true) {
	    var text	= assert.namespace+" #"+assert.count+":: "+(message || "Assertion failed with '"+condition+"'");
	    throw Error(text);
	}
    }
    assert.exception	= function(fn) {
	assert(true);
	try {
	    fn();
	} catch (err) {
	    log.debug("Controlled Error:", err.message);
	    log.trace(err);
	    return;
	}
	assert("Failed to throw an exception");
    }
    assert.namespace	= namespace;
    assert.count	= 0;
    return assert;
}
Testing.assert		= createAssertionNamespace("Global");
Testing.assert.count	= 0
Testing.assert.ns	= function(namespace) {
    return createAssertionNamespace(namespace);
}

Testing.api		= function(uri, opts) {
    // Options:
    //   params	= Object of URL get parameters
    //   data	= Object for request body (JSON dump if opts.json is true)
    //   json	= Bool indicates JSON based API (default: true)
    //   baseUrl	= String for request's baseUrl
    //   method	= String HTTP method (default: POST)
    //   timeout	= Number for timeout in milliseconds
    
    if (opts === undefined)
	opts	= {};

    opts.uri	= uri;
    return new Promise(function(f,r) {
	log.info((opts.method||"GET")+" request to "+opts.uri);
	log.debug("api() opts");
	log.debug(opts);
	requests(opts, function(err, resp, body) {
	    if (err) {
		log.error("Broke on "+(opts.method||"GET")+" request to "+opts.uri);
		log.error(err);
		r(err);
	    }
	    else {
		try {
		    if (typeof body === 'object' && body !== null)
			resp.data	= body;
		    else {
			log.info("Received response with "+body.length+" characters");
			resp.data	= JSON.parse(body);
		    }
		    log.debug(Object.keys(resp.data));
		} catch (e) {
		    log.debug("Body is not valid json:\n", resp.body);
		    resp.data	= {};
		}
		resp.body		= body;
		f(resp);
	    }
	});
    });
    
};

// {
//     uri: uri,
//     method: "POST",
//     qs: opts.params,
//     json: true,
//     body: opts.data,
//     baseUrl: "http://localhost/v1/"+api.appID,
//     timeout: 2000
// }

Testing.api.defaults	= function(defOpts, fns) {
    if (! (this instanceof Testing.api.defaults))
	return new Testing.api.defaults(defOpts, fns);

    log.info("Called api.defaults with");
    log.info(defOpts);
    log.info(fns);
    if (fns === undefined)
	fns		= [];
    else if (typeof fns === 'function')
	fns		= [fns];
    
    this.defOpts	= defOpts;
    this.fns		= fns;
    this.process	= function(uri, opts, fn) {
	// Run opts through the default processing function
	if (opts === undefined)
	    opts	= {};

	log.debug(opts);
	var opts	= typeof fn === "function"
	    ? fn(uri, opts)
	    : self.defOpts;
	log.debug(opts);

	if (typeof opts !== 'object' || opts === null)
	    throw Error('Options must be an object not '+(typeof opts));
	
	return opts;
    }
    
    var self		= this;
    var apiDefaults	= function(uri, opts) {
	if (opts === undefined)
	    opts	= {};
	var opts	= extend(extend({}, self.defOpts), opts);

	for (var i in self.fns) {
	    opts	= self.process(uri, opts, self.fns[i]);
	}

	return Testing.api.call(this ,uri, opts);
    }
    apiDefaults.defaults	= function(defOpts, fns) {
	defOpts		= extend(extend({}, self.defOpts), defOpts);
	if (fns === undefined)
	    fns		= [];
	else if (typeof fns === 'function')
	    fns		= [fns];
	
	fns		= self.fns.concat(fns);
	log.info("Calling sub defaults with");
	log.info(defOpts);
	log.info(fns);
	return Testing.api.defaults(defOpts, fns);
    }
    
    return apiDefaults;
}

module.exports = Testing;
